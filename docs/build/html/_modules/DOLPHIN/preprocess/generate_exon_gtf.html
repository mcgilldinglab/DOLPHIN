<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DOLPHIN.preprocess.generate_exon_gtf &mdash; DOLPHIN  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            DOLPHIN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started with DOLPHIN:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../API/index.html">API Documentations</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DOLPHIN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">DOLPHIN.preprocess.generate_exon_gtf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for DOLPHIN.preprocess.generate_exon_gtf</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">DOLPHIN.preprocess</span> <span class="kn">import</span> <span class="n">gtfpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
<span class="kn">from</span> <span class="nn">intervaltree</span> <span class="kn">import</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">IntervalTree</span>
<span class="kn">import</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>

<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;display.max_columns&#39;</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;display.max_rows&#39;</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<div class="viewcode-block" id="prepare_exon_gtf"><a class="viewcode-back" href="../../../API/preprocess.html#DOLPHIN.preprocess.generate_exon_gtf.prepare_exon_gtf">[docs]</a><span class="k">def</span> <span class="nf">prepare_exon_gtf</span><span class="p">(</span><span class="n">input_gtf_path</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load an Ensembl GTF file and extract exon-level annotations with unique start/end per gene.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_gtf_path : str</span>
<span class="sd">        Path to the original Ensembl .gtf file.</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Directory to save intermediate results (default: &#39;./dolphin_exon_gtf/&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_exon_nodup : pandas.DataFrame</span>
<span class="sd">        Filtered exon annotation table with duplicates (same gene_id, start, end) removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 1. Ensure output directory exists</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;dolphin_exon_gtf&quot;</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Step] Reading GTF file from: </span><span class="si">{</span><span class="n">input_gtf_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># 2. Load GTF and parse</span>
    <span class="n">df_gtf</span> <span class="o">=</span> <span class="n">gtfpy</span><span class="o">.</span><span class="n">readGTF</span><span class="p">(</span><span class="n">input_gtf_path</span><span class="p">)</span>
    <span class="n">GTFpa</span> <span class="o">=</span> <span class="n">gtfpy</span><span class="o">.</span><span class="n">parseGTF</span><span class="p">(</span><span class="n">df_gtf</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Status] GTF loaded and parsed with </span><span class="si">{</span><span class="n">GTFpa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> total entries.&quot;</span><span class="p">)</span>

    <span class="c1"># 3. Filter exon features and keep necessary columns</span>
    <span class="n">df_exon</span> <span class="o">=</span> <span class="n">GTFpa</span><span class="p">[</span><span class="n">GTFpa</span><span class="p">[</span><span class="s2">&quot;feature&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;exon&quot;</span><span class="p">][[</span>
        <span class="s1">&#39;seqname&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feature&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span>
        <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_version&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_name&#39;</span><span class="p">,</span>
        <span class="s1">&#39;gene_source&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_biotype&#39;</span><span class="p">,</span> <span class="s1">&#39;exon_number&#39;</span>
    <span class="p">]]</span>

    <span class="c1"># 4. Sort and convert coordinates</span>
    <span class="n">df_exon</span><span class="p">[[</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df_exon</span><span class="p">[[</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">)</span>
    <span class="n">df_exon</span> <span class="o">=</span> <span class="n">df_exon</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;seqname&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>

    <span class="c1"># 5. Remove duplicate exons (same gene, start, end)</span>
    <span class="n">df_exon_nodup</span> <span class="o">=</span> <span class="n">df_exon</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gene_id&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Status] Removed duplicates: </span><span class="si">{</span><span class="n">df_exon_nodup</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> unique exon entries remain.&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df_exon_nodup</span></div>

<span class="c1"># def exon_uniq(df_exon_nodup, gene):</span>
<span class="c1">#     # Subset exons for the given gene</span>
<span class="c1">#     _df_exon = df_exon_nodup.loc[df_exon_nodup[&quot;gene_id&quot;] == gene].reset_index(drop=True).copy()</span>

<span class="c1">#     # Create interval tree from exon start/end</span>
<span class="c1">#     # tree = IntervalTree(Interval(row[&quot;start&quot;], row[&quot;end&quot;]) for _, row in _df_exon.iterrows())</span>
<span class="c1">#     tree = IntervalTree(</span>
<span class="c1">#         Interval(row[&quot;start&quot;], row[&quot;end&quot;])</span>
<span class="c1">#         for _, row in _df_exon.iterrows()</span>
<span class="c1">#         if row[&quot;start&quot;] &lt; row[&quot;end&quot;]</span>
<span class="c1">#     )</span>
    
<span class="c1">#     # Merge overlapping exons</span>
<span class="c1">#     tree.merge_overlaps()</span>
    
<span class="c1">#     # Get sorted list of unique intervals</span>
<span class="c1">#     merged_intervals = sorted([(iv.begin, iv.end) for iv in tree])</span>

<span class="c1">#     # Assign merged coordinates to exons</span>
<span class="c1">#     _df_exon[&quot;_start&quot;] = math.nan</span>
<span class="c1">#     _df_exon[&quot;_end&quot;] = math.nan</span>

<span class="c1">#     for k in range(_df_exon.shape[0]):</span>
<span class="c1">#         for start, end in merged_intervals:</span>
<span class="c1">#             if start &lt;= _df_exon.at[k, &quot;start&quot;] and end &gt;= _df_exon.at[k, &quot;end&quot;]:</span>
<span class="c1">#                 _df_exon.at[k, &quot;_start&quot;] = start</span>
<span class="c1">#                 _df_exon.at[k, &quot;_end&quot;] = end</span>
<span class="c1">#                 break  # stop at first match</span>

<span class="c1">#     # Warn if any exon did not get matched</span>
<span class="c1">#     for i in range(_df_exon.shape[0]):</span>
<span class="c1">#         if math.isnan(_df_exon.at[i, &#39;_start&#39;]):</span>
<span class="c1">#             print(f&quot;Attention: {gene}, start={_df_exon.at[i,&#39;start&#39;]}, end={_df_exon.at[i,&#39;end&#39;]} was not assigned.&quot;)</span>

<span class="c1">#     # Keep only unique exons based on merged coordinates</span>
<span class="c1">#     _df_exon_out = _df_exon.drop_duplicates(subset=[&quot;_start&quot;, &quot;_end&quot;], keep=&quot;first&quot;).copy()</span>
<span class="c1">#     _df_exon_out[&quot;start&quot;] = _df_exon_out[&quot;_start&quot;].astype(int)</span>
<span class="c1">#     _df_exon_out[&quot;end&quot;] = _df_exon_out[&quot;_end&quot;].astype(int)</span>
<span class="c1">#     _df_exon_out.drop(columns=[&quot;_start&quot;, &quot;_end&quot;], inplace=True)</span>

<span class="c1">#     # Re-index exon numbers</span>
<span class="c1">#     _df_exon_out = _df_exon_out.reset_index(drop=True)</span>
<span class="c1">#     _df_exon_out[&quot;exon_number&quot;] = _df_exon_out.index + 1</span>

<span class="c1">#     return _df_exon_out</span>

<div class="viewcode-block" id="exon_uniq"><a class="viewcode-back" href="../../../API/preprocess.html#DOLPHIN.preprocess.generate_exon_gtf.exon_uniq">[docs]</a><span class="k">def</span> <span class="nf">exon_uniq</span><span class="p">(</span><span class="n">df_exon_nodup</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">gene</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge overlapping exons for a single gene using interval trees.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_exon_nodup : pandas.DataFrame</span>
<span class="sd">        DataFrame containing all exons (from `prepare_exon_gtf`), including gene IDs and coordinates.</span>
<span class="sd">    gene : str</span>
<span class="sd">        The gene ID whose exons will be processed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        A cleaned exon DataFrame for the given gene, where overlapping exons are merged,</span>
<span class="sd">        exon coordinates are updated, and exon numbers are reindexed. Exons that are</span>
<span class="sd">        invalid or cannot be matched to any merged region are excluded.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Subset exons for the given gene</span>
    <span class="n">_df_exon</span> <span class="o">=</span> <span class="n">df_exon_nodup</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_exon_nodup</span><span class="p">[</span><span class="s2">&quot;gene_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Return empty DataFrame if the gene has no exons</span>
    <span class="k">if</span> <span class="n">_df_exon</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Warning] Gene </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="s2"> has no exon entries.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">df_exon_nodup</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="c1"># Filter out invalid exons where start &gt;= end</span>
    <span class="n">_df_exon</span> <span class="o">=</span> <span class="n">_df_exon</span><span class="p">[</span><span class="n">_df_exon</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_df_exon</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_df_exon</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Warning] Gene </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="s2"> has only invalid exon coordinates (start &gt;= end).&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">df_exon_nodup</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="c1"># Create IntervalTree from valid exon intervals</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">valid_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Interval</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">_df_exon</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">IntervalTree</span><span class="p">(</span><span class="n">valid_intervals</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">merge_overlaps</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Error] IntervalTree failed for gene </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">df_exon_nodup</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="c1"># Extract merged, sorted non-overlapping intervals</span>
    <span class="n">merged_intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">iv</span><span class="o">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">iv</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">])</span>

    <span class="c1"># Initialize columns for matched merged coordinates</span>
    <span class="n">_df_exon</span><span class="p">[</span><span class="s2">&quot;_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">_df_exon</span><span class="p">[</span><span class="s2">&quot;_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Assign each exon to the first merged interval that fully contains it</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_df_exon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">merged_intervals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">_df_exon</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">_df_exon</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">]:</span>
                <span class="n">_df_exon</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
                <span class="n">_df_exon</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>
                <span class="k">break</span>  <span class="c1"># stop after the first match</span>

    <span class="c1"># Warn about unmatched exons</span>
    <span class="n">unmatched</span> <span class="o">=</span> <span class="n">_df_exon</span><span class="p">[</span><span class="n">_df_exon</span><span class="p">[</span><span class="s2">&quot;_start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">unmatched</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Warning] Gene </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="s2">: exon (start=</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, end=</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">) was not assigned to any merged region.&quot;</span><span class="p">)</span>

    <span class="c1"># Drop exons that failed to match any merged interval</span>
    <span class="n">_df_exon_out</span> <span class="o">=</span> <span class="n">_df_exon</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_start&quot;</span><span class="p">,</span> <span class="s2">&quot;_end&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># If no exons remain after matching, return empty</span>
    <span class="k">if</span> <span class="n">_df_exon_out</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Warning] Gene </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="s2"> has no exons remaining after merging.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">df_exon_nodup</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="c1"># Remove duplicate merged intervals, keeping only one exon per interval</span>
    <span class="n">_df_exon_out</span> <span class="o">=</span> <span class="n">_df_exon_out</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_start&quot;</span><span class="p">,</span> <span class="s2">&quot;_end&quot;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Convert merged coordinates to integer and replace original coordinates</span>
    <span class="n">_df_exon_out</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_df_exon_out</span><span class="p">[</span><span class="s2">&quot;_start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">_df_exon_out</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_df_exon_out</span><span class="p">[</span><span class="s2">&quot;_end&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">_df_exon_out</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_start&quot;</span><span class="p">,</span> <span class="s2">&quot;_end&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Re-index exon numbers</span>
    <span class="n">_df_exon_out</span> <span class="o">=</span> <span class="n">_df_exon_out</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_df_exon_out</span><span class="p">[</span><span class="s2">&quot;exon_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_df_exon_out</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">_df_exon_out</span></div>

<div class="viewcode-block" id="save_by_batch"><a class="viewcode-back" href="../../../API/preprocess.html#DOLPHIN.preprocess.generate_exon_gtf.save_by_batch">[docs]</a><span class="k">def</span> <span class="nf">save_by_batch</span><span class="p">(</span><span class="n">df_exon_nodup</span><span class="p">,</span> <span class="n">save_num</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process exon annotations for each gene in batches and save results as serialized .pkl files.</span>

<span class="sd">    This function applies `exon_uniq()` to each gene in the input DataFrame and saves the processed</span>
<span class="sd">    exon data in batches. Each batch contains up to `save_num` genes and is written to a pickle file.</span>
<span class="sd">    A log file is generated to record processing status and potential errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_exon_nodup : pandas.DataFrame</span>
<span class="sd">        DataFrame containing filtered exon annotations (typically from `prepare_exon_gtf`).</span>
<span class="sd">    save_num : int, optional</span>
<span class="sd">        Number of genes to include per output batch file (default is 10,000).</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Path to the output directory where batch `.pkl` files and the log file will be stored</span>
<span class="sd">        (default is &quot;./&quot;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        This function writes intermediate results to disk but does not return any object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Step] Start processing and saving exons by batch...&quot;</span><span class="p">)</span>

    <span class="c1"># 1. Create temp folder</span>
    <span class="n">temp_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;dolphin_exon_gtf&quot;</span><span class="p">,</span> <span class="s2">&quot;temp&quot;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># delete all .pkl 文件</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="s2">&quot;df_exon_gtf_*.pkl&quot;</span><span class="p">)):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="c1"># delete all log 文件</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span><span class="s2">&quot;process_log.txt&quot;</span><span class="p">)):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;temp/process_log.txt&quot;</span><span class="p">)</span>
    
    <span class="c1"># 2. Gene list</span>
    <span class="n">gene_list</span> <span class="o">=</span> <span class="n">df_exon_nodup</span><span class="p">[</span><span class="s2">&quot;gene_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">total_genes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_list</span><span class="p">)</span>

    <span class="c1"># 3. Initialize list for all batch DataFrames (optional, for further processing)</span>
    <span class="n">list_of_df</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">log_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="s2">&quot;process_log.txt&quot;</span><span class="p">)</span>

    <span class="c1"># 4. Track current batch number</span>
    <span class="n">current_batch</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">df_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="c1"># 5. Process all genes with a unified tqdm progress bar</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">gene_list</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">total_genes</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing all genes&quot;</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_temp</span> <span class="o">=</span> <span class="n">exon_uniq</span><span class="p">(</span><span class="n">df_exon_nodup</span><span class="p">,</span> <span class="n">gene</span><span class="p">)</span>
            <span class="n">df_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_out</span><span class="p">,</span> <span class="n">_temp</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch </span><span class="si">{</span><span class="n">current_batch</span><span class="si">}</span><span class="s2">, Processed gene: </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch </span><span class="si">{</span><span class="n">current_batch</span><span class="si">}</span><span class="s2">, Error processing gene </span><span class="si">{</span><span class="n">gene</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>  <span class="c1"># skip gene with error</span>

        <span class="c1"># Save this batch every save_num genes or at the end</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">save_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">total_genes</span><span class="p">):</span>
            <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;df_exon_gtf_</span><span class="si">{</span><span class="n">current_batch</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">)</span>
            <span class="n">df_out</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="n">list_of_df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_out</span><span class="p">)</span>
            <span class="n">df_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>  <span class="c1"># reset for next batch</span>
            <span class="n">current_batch</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Done] Finished saving all exon batches.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="combine_saved_batches"><a class="viewcode-back" href="../../../API/preprocess.html#DOLPHIN.preprocess.generate_exon_gtf.combine_saved_batches">[docs]</a><span class="k">def</span> <span class="nf">combine_saved_batches</span><span class="p">(</span><span class="n">folder</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;df_exon_gtf_&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine multiple saved exon batch files into a single concatenated DataFrame.</span>

<span class="sd">    This function reads all `.pkl` files in the specified folder that start with the given prefix,</span>
<span class="sd">    concatenates them in order, and returns a single DataFrame containing all exon records.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    folder : str, optional</span>
<span class="sd">        Directory where batch `.pkl` files are stored.</span>
<span class="sd">        Default is &quot;./&quot;, which typically points to the parent of &quot;dolphin_exon_gtf/temp&quot;.</span>
<span class="sd">    prefix : str, optional</span>
<span class="sd">        Filename prefix used to identify batch `.pkl` files.</span>
<span class="sd">        Default is ``df_exon_gtf_``.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        A single DataFrame containing concatenated exon entries from all batch files.</span>
<span class="sd">        The rows are ordered according to batch and file sorting.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">temp_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;dolphin_exon_gtf&quot;</span><span class="p">,</span> <span class="s2">&quot;temp&quot;</span><span class="p">)</span>
    <span class="c1"># List all matching .pkl files in the folder</span>
    <span class="n">pkl_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">)</span>
                 <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.pkl&quot;</span><span class="p">)]</span>

    <span class="c1"># Sort to ensure batch order is respected</span>
    <span class="n">pkl_files</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pkl_files</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No .pkl files found in &#39;</span><span class="si">{</span><span class="n">temp_dir</span><span class="si">}</span><span class="s2">&#39; with prefix &#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Read and concatenate</span>
    <span class="n">dataframes</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">pkl_files</span><span class="p">]</span>
    <span class="n">combined_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dataframes</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully combined </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pkl_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> files into a single DataFrame with </span><span class="si">{</span><span class="n">combined_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> rows.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">combined_df</span></div>

<div class="viewcode-block" id="check_exon_overlap"><a class="viewcode-back" href="../../../API/preprocess.html#DOLPHIN.preprocess.generate_exon_gtf.check_exon_overlap">[docs]</a><span class="k">def</span> <span class="nf">check_exon_overlap</span><span class="p">(</span><span class="n">gtf_df</span><span class="p">,</span> <span class="n">expected_gene_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check for overlapping adjacent exon intervals within each gene.</span>

<span class="sd">    This function checks whether any exons within the same gene have overlapping intervals,</span>
<span class="sd">    based on their `start` and `end` positions. Optionally, it compares the set of gene IDs</span>
<span class="sd">    in the provided DataFrame with an expected list to detect any missing or extra genes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtf_df : pandas.DataFrame</span>
<span class="sd">        A DataFrame containing exon annotations with at least the columns: &#39;gene_id&#39;, &#39;start&#39;, and &#39;end&#39;.</span>
<span class="sd">    expected_gene_list : list of str, optional</span>
<span class="sd">        A list of expected gene IDs used to validate that all genes were processed and included in `gtf_df`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        A DataFrame containing exon entries that overlap with their adjacent exons within the same gene.</span>
<span class="sd">        The result may be empty if no overlaps are detected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">df_check</span> <span class="o">=</span> <span class="n">gtf_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Sort by gene and start for correct order</span>
    <span class="n">df_check</span> <span class="o">=</span> <span class="n">df_check</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gene_id&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Get the start of the next exon within each gene</span>
    <span class="n">df_check</span><span class="p">[</span><span class="s1">&#39;_next_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_check</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;gene_id&#39;</span><span class="p">)[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Initialize overlap check column</span>
    <span class="n">df_check</span><span class="p">[</span><span class="s1">&#39;_overlap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Check if next exon starts after or at the end of current exon</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df_check</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df_check</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;_next_start&#39;</span><span class="p">]):</span>
            <span class="n">df_check</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;_overlap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Last exon of gene</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df_check</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;_overlap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_check</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;_next_start&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">df_check</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">]</span>

    <span class="c1"># Filter exons that overlap with the next one</span>
    <span class="n">overlap_issues</span> <span class="o">=</span> <span class="n">df_check</span><span class="p">[</span><span class="n">df_check</span><span class="p">[</span><span class="s1">&#39;_overlap&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">overlap_issues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> overlapping exon entries.&quot;</span><span class="p">)</span>

    <span class="c1"># If expected gene list is provided, validate gene count</span>
    <span class="k">if</span> <span class="n">expected_gene_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_genes_in_df</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gtf_df</span><span class="p">[</span><span class="s2">&quot;gene_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">expected_genes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">expected_gene_list</span><span class="p">)</span>
        <span class="n">missing_genes</span> <span class="o">=</span> <span class="n">expected_genes</span> <span class="o">-</span> <span class="n">unique_genes_in_df</span>
        <span class="n">extra_genes</span> <span class="o">=</span> <span class="n">unique_genes_in_df</span> <span class="o">-</span> <span class="n">expected_genes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">missing_genes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">extra_genes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expected_genes</span><span class="p">)</span><span class="si">}</span><span class="s2"> expected genes are present in the merged DataFrame.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gene count mismatch:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_genes</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_genes</span><span class="p">)</span><span class="si">}</span><span class="s2"> gene(s) missing: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">missing_genes</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extra_genes</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">extra_genes</span><span class="p">)</span><span class="si">}</span><span class="s2"> unexpected gene(s): </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">extra_genes</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">overlap_issues</span></div>

<div class="viewcode-block" id="save_gtf_outputs"><a class="viewcode-back" href="../../../API/preprocess.html#DOLPHIN.preprocess.generate_exon_gtf.save_gtf_outputs">[docs]</a><span class="k">def</span> <span class="nf">save_gtf_outputs</span><span class="p">(</span><span class="n">gtf_df</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span> <span class="n">base_name</span><span class="o">=</span><span class="s2">&quot;dolphin.exon&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save the final exon DataFrame to both GTF and Pickle formats.</span>

<span class="sd">    This function writes the given exon annotation table to two output files:</span>
<span class="sd">    one in standard GTF format, and the other as a serialized Python pickle (.pkl).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtf_df : pandas.DataFrame</span>
<span class="sd">        The exon annotation DataFrame to be saved.</span>
<span class="sd">    output_dir : str, optional</span>
<span class="sd">        Directory where the output files will be saved (default is the current directory).</span>
<span class="sd">    base_name : str, optional</span>
<span class="sd">        Filename prefix used for both output files (default is &quot;dolphin.exon&quot;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        &lt;output_dir&gt;/dolphin_exon_gtf/&lt;base_name&gt;.gtf : GTF-format annotation file</span>
<span class="sd">        &lt;output_dir&gt;/dolphin_exon_gtf/&lt;base_name&gt;.pkl : Pickle-serialized DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build full output paths</span>
    <span class="n">gtf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;dolphin_exon_gtf&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_name</span><span class="si">}</span><span class="s2">.gtf&quot;</span><span class="p">))</span>
    <span class="n">pkl_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;dolphin_exon_gtf&quot;</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_name</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">))</span>

    <span class="c1"># Write to GTF</span>
    <span class="n">gtfpy</span><span class="o">.</span><span class="n">writeGTF</span><span class="p">(</span><span class="n">gtf_df</span><span class="p">,</span> <span class="n">gtf_path</span><span class="p">)</span>

    <span class="c1"># Write to Pickle</span>
    <span class="n">gtf_df</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="n">pkl_path</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GTF file saved to: </span><span class="si">{</span><span class="n">gtf_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pickle file saved to: </span><span class="si">{</span><span class="n">pkl_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="generate_nonoverlapping_exons"><a class="viewcode-back" href="../../../API/preprocess.html#DOLPHIN.preprocess.generate_exon_gtf.generate_nonoverlapping_exons">[docs]</a><span class="k">def</span> <span class="nf">generate_nonoverlapping_exons</span><span class="p">(</span><span class="n">input_gtf_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    End-to-end pipeline to process an Ensembl GTF file and generate non-overlapping exons per gene.</span>

<span class="sd">    This function performs the following steps:</span>
<span class="sd">    1. Load and filter exon features from a GTF file.</span>
<span class="sd">    2. Remove duplicate exons (by gene_id, start, end).</span>
<span class="sd">    3. Process each gene to merge overlapping exons using IntervalTree.</span>
<span class="sd">    4. Save intermediate results in batches.</span>
<span class="sd">    5. Combine all batches into a final exon DataFrame.</span>
<span class="sd">    6. Optionally check for residual overlaps.</span>
<span class="sd">    7. Save the final results in GTF and Pickle formats.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_gtf_path : str</span>
<span class="sd">        Path to the input Ensembl-format GTF file.</span>
<span class="sd">    output_dir : str</span>
<span class="sd">        Directory to save intermediate and final output files.</span>
<span class="sd">    batch_size : int</span>
<span class="sd">        Number of genes to process and save per batch (default: 10000).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gtf_all : pd.DataFrame</span>
<span class="sd">        Final merged and cleaned exon annotation table.</span>
<span class="sd">    overlap_issues : pd.DataFrame</span>
<span class="sd">        DataFrame of overlapping exons detected post-processing (if any).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Step 1: Load exon entries from GTF and remove duplicates</span>
    <span class="n">df_exon_nodup</span> <span class="o">=</span> <span class="n">prepare_exon_gtf</span><span class="p">(</span><span class="n">input_gtf_path</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="c1"># Step 2: Process and save exons by gene in batches</span>
    <span class="n">save_by_batch</span><span class="p">(</span><span class="n">df_exon_nodup</span><span class="p">,</span> <span class="n">save_num</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="c1"># Step 3: Combine saved batches</span>
    <span class="n">gtf_all</span> <span class="o">=</span> <span class="n">combine_saved_batches</span><span class="p">(</span><span class="n">folder</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="c1"># Step 4: Check for residual overlaps</span>
    <span class="n">overlap_issues</span> <span class="o">=</span> <span class="n">check_exon_overlap</span><span class="p">(</span><span class="n">gtf_all</span><span class="p">,</span> <span class="n">expected_gene_list</span><span class="o">=</span><span class="n">df_exon_nodup</span><span class="p">[</span><span class="s2">&quot;gene_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="c1"># Step 5: Save final GTF and pickle files</span>
    <span class="n">save_gtf_outputs</span><span class="p">(</span><span class="n">gtf_all</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Success] Exon GTF processing pipeline completed.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gtf_all</span><span class="p">,</span> <span class="n">overlap_issues</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Ding Lab at McGill University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>