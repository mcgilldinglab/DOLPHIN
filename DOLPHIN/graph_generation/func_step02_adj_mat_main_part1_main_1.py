import pandas as pd
import numpy as np
import os
import anndata
from scipy.sparse import csr_matrix
import gc

def combine_adj(pbar, pd_gt, graph_path, gtf_jun_pkl_path, start_idx, sample_num, output_path, output_name):
    """
    Combines per-cell junction-level read counts generated by FeatureCounts into a single AnnData object containing adjacency matrices.

    This function reads individual adjacency matrices for a batch of cells (from CSV files),
    merges them with cell-level metadata, and attaches gene-junction annotations
    to create an AnnData object. The resulting sparse matrix is saved in `.h5ad` format
    for downstream graph-based modeling.

    Parameters
    ----------
    pbar : tqdm.tqdm
        A progress bar object used to track the combination process.
    pd_gt : pandas.DataFrame
        A DataFrame containing metadata for each cell, including barcodes (`CB`) and cell labels.
    graph_path : str
        Path to the directory where per-cell junction reads files.
    gtf_jun_pkl_path : str
        Path to the pickled DataFrame with exon junction annotation (should contain `Gene_Junc_name`, `Geneid`, `GeneName`).
    start_idx : int
        Index of the first cell in the batch to process.
    sample_num : int
        Number of cells to process in this batch.
    output_path : str
        Path where the resulting `.h5ad` file will be saved.
    output_name : str
        Prefix to use for naming the output `.h5ad` file.

    Returns
    -------
    pbar : tqdm.tqdm
        The progress bar object after being updated.

    Notes
    -----
    - Each per-cell adjacency matrix is assumed to be a 1D flattened array saved in a `.csv` file.
    - The final data matrix is stored in sparse CSR format within the AnnData object to save memory.
    - The output filename will be: `Adjacency_<output_name>_<batch_index>.h5ad`.

    Example
    -------
    >>> from tqdm import tqdm
    >>> pbar = tqdm(total=50)
    >>> combine_adj(pbar, pd_gt, './graph_data/', 'junction_gtf.pkl', 0, 50, './out/', 'batch1')
    """
    
    '''
    combine all adjacency matrix together
    '''
    cell_adj = np.array([[]])
    # _df_temp = pd_gt
    cell_list = list(pd_gt["CB"])

    if start_idx+sample_num > len(cell_list):
        end_idx = len(cell_list)
    else:
        end_idx = start_idx+sample_num 

    for i, _cb in enumerate(cell_list[start_idx:end_idx]):
        _temp_adj = np.array([np.loadtxt(os.path.join(graph_path, _cb + "_adj.csv"))])
        _temp_lable = pd_gt[pd_gt["CB"] == _cb].to_numpy()
        _temp_all = np.concatenate((_temp_lable, _temp_adj), axis=1)
        if i == 0:
            cell_adj = _temp_all
        else: 
            cell_adj = np.concatenate((cell_adj, _temp_all), axis=0)
        pbar.update(1)

    df_adj = pd.DataFrame(cell_adj)

    df_jun_gtf = pd.read_pickle(gtf_jun_pkl_path)

    ## adata for adjacency matrix
    obs_names = df_adj[0].values
    obs = pd.DataFrame(index=obs_names)
    for _i, _col_name in enumerate(pd_gt.columns):
        obs[_col_name] = df_adj[_i].values

    ## dataframe for annotating the variables = geneid
    var_names = df_jun_gtf["Gene_Junc_name"].values
    var = pd.DataFrame(index=var_names)
    var["gene_id"] = df_jun_gtf["Geneid"].values
    var["gene_name"] = df_jun_gtf["GeneName"].values

    # ##the data matrix 
    X = df_adj.iloc[:,pd_gt.shape[1]::].values
    adata = anndata.AnnData(X=X, obs=obs, var=var, dtype=np.float32)
    adata.X = csr_matrix(adata.X)

    adata.write(os.path.join(output_path, "Adjacency_"+output_name+"_"+str(int(start_idx/sample_num))+".h5ad"))
    
    del adata
    del cell_adj
    gc.collect()
    
    return pbar